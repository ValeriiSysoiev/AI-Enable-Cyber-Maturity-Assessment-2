From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Valerii Sysoiev <valsysoiev@gmail.com>
Date: Mon, 18 Aug 2025 16:30:49 -0600
Subject: [PATCH 81/90] feat: merge S4 minutes publish immutable
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add Minutes, MinutesSection models with content hashing
- Implement draft/published states with immutability
- Add content integrity validation using SHA-256
- Support versioning for editing published minutes
- Integrate minutes router and Cosmos DB storage
- Merge all S4 features: Service Bus, CSF, Workshops, Minutes

ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/api/main.py b/app/api/main.py
index a18945d86edbb166d2f8f6310bcdcce5dcec9077..800b1a066b6d0b25d128464b8ed52b36f3a593e1 100644
--- a/app/api/main.py
+++ b/app/api/main.py
@@ -14,7 +14,7 @@ from .db import create_db_and_tables, get_session
 from .models import Assessment, Answer
 from .schemas import AssessmentCreate, AssessmentResponse, AnswerUpsert, ScoreResponse, PillarScore
 from .scoring import compute_scores
-from .routes import assessments as assessments_router, orchestrations as orchestrations_router, engagements as engagements_router, documents, summary, presets as presets_router, version as version_router, admin_auth as admin_auth_router, gdpr as gdpr_router, admin_settings as admin_settings_router, evidence as evidence_router, csf as csf_router, workshops as workshops_router
+from .routes import assessments as assessments_router, orchestrations as orchestrations_router, engagements as engagements_router, documents, summary, presets as presets_router, version as version_router, admin_auth as admin_auth_router, gdpr as gdpr_router, admin_settings as admin_settings_router, evidence as evidence_router, csf as csf_router, workshops as workshops_router, minutes as minutes_router
 from domain.repository import InMemoryRepository
 from domain.file_repo import FileRepository
 from ai.llm import LLMClient
@@ -285,6 +285,7 @@ app.include_router(admin_settings_router.router)
 app.include_router(evidence_router.router)
 app.include_router(csf_router.router)
 app.include_router(workshops_router.router)
+app.include_router(minutes_router.router)
 
 def load_preset(preset_id: str) -> dict:
     # Use new preset service for consistency
diff --git a/app/api/routes/minutes.py b/app/api/routes/minutes.py
new file mode 100644
index 0000000000000000000000000000000000000000..c51df2220b94b9706521d1ecfd7cbef92db078b0
--- /dev/null
+++ b/app/api/routes/minutes.py
@@ -0,0 +1,525 @@
+"""
+Minutes API Routes
+
+Provides endpoints for managing workshop minutes:
+- Generate draft minutes from workshop data
+- Update draft minutes
+- Retrieve minutes by ID
+"""
+
+from fastapi import APIRouter, Depends, HTTPException, Request
+import logging
+import uuid
+from datetime import datetime, timezone
+from typing import Optional, Dict, Any
+from pydantic import BaseModel, Field
+
+from domain.repository import Repository
+from domain.models import Minutes, MinutesSection
+from repos.cosmos_repository import CosmosRepository
+from ..security import current_context, require_member
+from services.minutes_agent import create_minutes_agent
+from config import config
+
+logger = logging.getLogger(__name__)
+
+# Response models
+class MinutesResponse(BaseModel):
+    """Public minutes response model"""
+    id: str
+    workshop_id: str
+    status: str
+    sections: MinutesSection
+    generated_by: str
+    published_at: Optional[datetime] = None
+    content_hash: Optional[str] = None
+    parent_id: Optional[str] = None
+    created_at: datetime
+    updated_by: str
+
+class GenerateMinutesRequest(BaseModel):
+    """Request model for generating minutes"""
+    workshop_type: str = Field(default="general")
+    attendees: Optional[list[str]] = None
+    additional_context: Optional[Dict[str, Any]] = None
+
+class UpdateMinutesRequest(BaseModel):
+    """Request model for updating draft minutes"""
+    sections: MinutesSection
+
+# Router setup
+router = APIRouter(prefix="/api/v1", tags=["minutes"])
+
+def get_repo(request: Request) -> Repository:
+    return request.app.state.repo
+
+def get_correlation_id(request: Request) -> str:
+    """Extract correlation ID from request headers"""
+    return request.headers.get(config.logging.correlation_id_header, str(uuid.uuid4()))
+
+@router.post("/workshops/{workshop_id}/minutes:generate", response_model=MinutesResponse)
+async def generate_minutes(
+    workshop_id: str,
+    request_data: GenerateMinutesRequest,
+    request: Request,
+    repo: Repository = Depends(get_repo),
+    ctx = Depends(current_context)
+):
+    """
+    Generate draft minutes for a workshop using the Minutes Agent.
+    Creates a new Minutes document with status='draft' and generatedBy='agent'.
+    
+    Requires engagement membership for the workshop's engagement.
+    """
+    # Note: For S4, we assume workshop_id maps to engagement_id for simplicity
+    # In a full implementation, we'd lookup the workshop's engagement_id
+    engagement_id = ctx["engagement_id"]
+    
+    # Verify user has access to the engagement
+    require_member(repo, ctx, "member")
+    
+    correlation_id = get_correlation_id(request)
+    
+    logger.info(
+        "Generating minutes for workshop",
+        extra={
+            "correlation_id": correlation_id,
+            "workshop_id": workshop_id,
+            "engagement_id": engagement_id,
+            "user_email": ctx["user_email"],
+            "workshop_type": request_data.workshop_type
+        }
+    )
+    
+    try:
+        # Create workshop data for the agent
+        workshop_data = {
+            "id": workshop_id,
+            "type": request_data.workshop_type,
+            "attendees": request_data.attendees or [],
+            "additional_context": request_data.additional_context or {}
+        }
+        
+        # Generate minutes using the agent
+        minutes_agent = create_minutes_agent(correlation_id)
+        minutes_section = await minutes_agent.generate_draft_minutes(workshop_data)
+        
+        # Create the Minutes model
+        minutes = Minutes(
+            workshop_id=workshop_id,
+            status="draft",
+            sections=minutes_section,
+            generated_by="agent",
+            updated_by=ctx["user_email"]
+        )
+        
+        # Store in repository
+        if isinstance(repo, CosmosRepository):
+            stored_minutes = await repo._create_minutes_async(minutes)
+        else:
+            stored_minutes = repo.create_minutes(minutes)
+        
+        logger.info(
+            "Successfully generated minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": stored_minutes.id,
+                "workshop_id": workshop_id,
+                "engagement_id": engagement_id,
+                "sections_count": {
+                    "attendees": len(stored_minutes.sections.attendees),
+                    "decisions": len(stored_minutes.sections.decisions),
+                    "actions": len(stored_minutes.sections.actions),
+                    "questions": len(stored_minutes.sections.questions)
+                }
+            }
+        )
+        
+        # Return response
+        return MinutesResponse(
+            id=stored_minutes.id,
+            workshop_id=stored_minutes.workshop_id,
+            status=stored_minutes.status,
+            sections=stored_minutes.sections,
+            generated_by=stored_minutes.generated_by,
+            published_at=stored_minutes.published_at,
+            content_hash=stored_minutes.content_hash,
+            parent_id=stored_minutes.parent_id,
+            created_at=stored_minutes.created_at,
+            updated_by=stored_minutes.updated_by
+        )
+        
+    except Exception as e:
+        logger.error(
+            "Failed to generate minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "workshop_id": workshop_id,
+                "engagement_id": engagement_id,
+                "error": str(e)
+            }
+        )
+        raise HTTPException(status_code=500, detail=f"Failed to generate minutes: {str(e)}")
+
+@router.patch("/minutes/{minutes_id}", response_model=MinutesResponse)
+async def update_minutes(
+    minutes_id: str,
+    request_data: UpdateMinutesRequest,
+    request: Request,
+    repo: Repository = Depends(get_repo),
+    ctx = Depends(current_context)
+):
+    """
+    Update draft minutes. Only allows edits when status='draft'.
+    Requires engagement membership.
+    """
+    correlation_id = get_correlation_id(request)
+    engagement_id = ctx["engagement_id"]
+    
+    logger.info(
+        "Updating minutes",
+        extra={
+            "correlation_id": correlation_id,
+            "minutes_id": minutes_id,
+            "engagement_id": engagement_id,
+            "user_email": ctx["user_email"]
+        }
+    )
+    
+    try:
+        # Get existing minutes
+        existing_minutes = None
+        if isinstance(repo, CosmosRepository):
+            # For Cosmos, we need to find the minutes by querying all workshops in engagement
+            # This is a simplification - in practice we'd have better indexing
+            raise HTTPException(status_code=501, detail="Cosmos update not implemented in S4")
+        else:
+            existing_minutes = repo.get_minutes(minutes_id)
+        
+        if not existing_minutes:
+            raise HTTPException(status_code=404, detail="Minutes not found")
+        
+        # Verify user has access to the engagement (simplified check)
+        require_member(repo, ctx, "member")
+        
+        # Only allow edits on draft status
+        if existing_minutes.status != "draft":
+            logger.warning(
+                "Attempted to edit non-draft minutes",
+                extra={
+                    "correlation_id": correlation_id,
+                    "minutes_id": minutes_id,
+                    "current_status": existing_minutes.status,
+                    "user_email": ctx["user_email"]
+                }
+            )
+            raise HTTPException(
+                status_code=409, 
+                detail=f"Cannot edit published minutes. Use POST /api/v1/minutes/{minutes_id}/versions/new to create a new version."
+            )
+        
+        # Update the minutes
+        updated_minutes = Minutes(
+            id=existing_minutes.id,
+            workshop_id=existing_minutes.workshop_id,
+            status=existing_minutes.status,  # Keep current status
+            sections=request_data.sections,
+            generated_by="human",  # Changed to human since user edited
+            published_at=existing_minutes.published_at,
+            content_hash=existing_minutes.content_hash,
+            parent_id=existing_minutes.parent_id,
+            created_at=existing_minutes.created_at,
+            updated_by=ctx["user_email"]
+        )
+        
+        # Store updated minutes
+        if isinstance(repo, CosmosRepository):
+            stored_minutes = await repo._update_minutes_async(updated_minutes)
+        else:
+            stored_minutes = repo.update_minutes(updated_minutes)
+        
+        logger.info(
+            "Successfully updated minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": stored_minutes.id,
+                "updated_by": stored_minutes.updated_by,
+                "generated_by": stored_minutes.generated_by
+            }
+        )
+        
+        # Return response
+        return MinutesResponse(
+            id=stored_minutes.id,
+            workshop_id=stored_minutes.workshop_id,
+            status=stored_minutes.status,
+            sections=stored_minutes.sections,
+            generated_by=stored_minutes.generated_by,
+            published_at=stored_minutes.published_at,
+            content_hash=stored_minutes.content_hash,
+            parent_id=stored_minutes.parent_id,
+            created_at=stored_minutes.created_at,
+            updated_by=stored_minutes.updated_by
+        )
+        
+    except HTTPException:
+        raise
+    except Exception as e:
+        logger.error(
+            "Failed to update minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": minutes_id,
+                "error": str(e)
+            }
+        )
+        raise HTTPException(status_code=500, detail=f"Failed to update minutes: {str(e)}")
+
+@router.get("/minutes/{minutes_id}", response_model=MinutesResponse)
+async def get_minutes(
+    minutes_id: str,
+    request: Request,
+    repo: Repository = Depends(get_repo),
+    ctx = Depends(current_context)
+):
+    """
+    Get minutes by ID. Requires engagement membership.
+    """
+    correlation_id = get_correlation_id(request)
+    engagement_id = ctx["engagement_id"]
+    
+    # Verify user has access to the engagement
+    require_member(repo, ctx, "member")
+    
+    logger.info(
+        "Retrieving minutes",
+        extra={
+            "correlation_id": correlation_id,
+            "minutes_id": minutes_id,
+            "engagement_id": engagement_id,
+            "user_email": ctx["user_email"]
+        }
+    )
+    
+    try:
+        # Get minutes
+        minutes = None
+        if isinstance(repo, CosmosRepository):
+            raise HTTPException(status_code=501, detail="Cosmos get not implemented in S4")
+        else:
+            minutes = repo.get_minutes(minutes_id)
+        
+        if not minutes:
+            raise HTTPException(status_code=404, detail="Minutes not found")
+        
+        # Log access for audit
+        logger.info(
+            "Minutes retrieved successfully",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": minutes_id,
+                "workshop_id": minutes.workshop_id,
+                "status": minutes.status,
+                "accessed_by": ctx["user_email"]
+            }
+        )
+        
+        # Return response
+        return MinutesResponse(
+            id=minutes.id,
+            workshop_id=minutes.workshop_id,
+            status=minutes.status,
+            sections=minutes.sections,
+            generated_by=minutes.generated_by,
+            published_at=minutes.published_at,
+            content_hash=minutes.content_hash,
+            parent_id=minutes.parent_id,
+            created_at=minutes.created_at,
+            updated_by=minutes.updated_by
+        )
+        
+    except HTTPException:
+        raise
+    except Exception as e:
+        logger.error(
+            "Failed to retrieve minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": minutes_id,
+                "error": str(e)
+            }
+        )
+        raise HTTPException(status_code=500, detail=f"Failed to retrieve minutes: {str(e)}")
+
+@router.post("/minutes/{minutes_id}:publish", response_model=MinutesResponse)
+async def publish_minutes(
+    minutes_id: str,
+    request: Request,
+    repo: Repository = Depends(get_repo),
+    ctx = Depends(current_context)
+):
+    """
+    Publish minutes by computing content hash, setting status='published', 
+    and publishedAt timestamp. Only draft minutes can be published.
+    Published minutes become immutable.
+    """
+    correlation_id = get_correlation_id(request)
+    engagement_id = ctx["engagement_id"]
+    
+    # Verify user has access to the engagement
+    require_member(repo, ctx, "member")
+    
+    logger.info(
+        "Publishing minutes",
+        extra={
+            "correlation_id": correlation_id,
+            "minutes_id": minutes_id,
+            "engagement_id": engagement_id,
+            "user_email": ctx["user_email"]
+        }
+    )
+    
+    try:
+        # Publish the minutes using repository method
+        published_minutes = None
+        if isinstance(repo, CosmosRepository):
+            published_minutes = await repo._publish_minutes_async(minutes_id)
+        else:
+            published_minutes = repo.publish_minutes(minutes_id)
+        
+        logger.info(
+            "Successfully published minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": published_minutes.id,
+                "workshop_id": published_minutes.workshop_id,
+                "content_hash": published_minutes.content_hash,
+                "published_at": published_minutes.published_at,
+                "published_by": ctx["user_email"]
+            }
+        )
+        
+        # Return response
+        return MinutesResponse(
+            id=published_minutes.id,
+            workshop_id=published_minutes.workshop_id,
+            status=published_minutes.status,
+            sections=published_minutes.sections,
+            generated_by=published_minutes.generated_by,
+            published_at=published_minutes.published_at,
+            content_hash=published_minutes.content_hash,
+            parent_id=published_minutes.parent_id,
+            created_at=published_minutes.created_at,
+            updated_by=published_minutes.updated_by
+        )
+        
+    except ValueError as e:
+        # Handle business logic errors (not found, wrong status, etc.)
+        logger.warning(
+            "Failed to publish minutes - business logic error",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": minutes_id,
+                "error": str(e),
+                "user_email": ctx["user_email"]
+            }
+        )
+        raise HTTPException(status_code=400, detail=str(e))
+    except HTTPException:
+        raise
+    except Exception as e:
+        logger.error(
+            "Failed to publish minutes",
+            extra={
+                "correlation_id": correlation_id,
+                "minutes_id": minutes_id,
+                "error": str(e)
+            }
+        )
+        raise HTTPException(status_code=500, detail=f"Failed to publish minutes: {str(e)}")
+
+@router.post("/minutes/{minutes_id}/versions/new", response_model=MinutesResponse)
+async def create_new_version(
+    minutes_id: str,
+    request: Request,
+    repo: Repository = Depends(get_repo),
+    ctx = Depends(current_context)
+):
+    """
+    Create a new draft version of published minutes for editing.
+    The new version will have a parent_id reference to the original.
+    This allows editing published minutes without breaking immutability.
+    """
+    correlation_id = get_correlation_id(request)
+    engagement_id = ctx["engagement_id"]
+    
+    # Verify user has access to the engagement
+    require_member(repo, ctx, "member")
+    
+    logger.info(
+        "Creating new version of minutes",
+        extra={
+            "correlation_id": correlation_id,
+            "parent_minutes_id": minutes_id,
+            "engagement_id": engagement_id,
+            "user_email": ctx["user_email"]
+        }
+    )
+    
+    try:
+        # Create new version using repository method
+        new_version = None
+        if isinstance(repo, CosmosRepository):
+            new_version = await repo._create_new_version_async(minutes_id, ctx["user_email"])
+        else:
+            new_version = repo.create_new_version(minutes_id, ctx["user_email"])
+        
+        logger.info(
+            "Successfully created new version",
+            extra={
+                "correlation_id": correlation_id,
+                "new_minutes_id": new_version.id,
+                "parent_minutes_id": minutes_id,
+                "workshop_id": new_version.workshop_id,
+                "created_by": ctx["user_email"]
+            }
+        )
+        
+        # Return response
+        return MinutesResponse(
+            id=new_version.id,
+            workshop_id=new_version.workshop_id,
+            status=new_version.status,
+            sections=new_version.sections,
+            generated_by=new_version.generated_by,
+            published_at=new_version.published_at,
+            content_hash=new_version.content_hash,
+            parent_id=new_version.parent_id,
+            created_at=new_version.created_at,
+            updated_by=new_version.updated_by
+        )
+        
+    except ValueError as e:
+        # Handle business logic errors (parent not found, etc.)
+        logger.warning(
+            "Failed to create new version - business logic error",
+            extra={
+                "correlation_id": correlation_id,
+                "parent_minutes_id": minutes_id,
+                "error": str(e),
+                "user_email": ctx["user_email"]
+            }
+        )
+        raise HTTPException(status_code=400, detail=str(e))
+    except HTTPException:
+        raise
+    except Exception as e:
+        logger.error(
+            "Failed to create new version",
+            extra={
+                "correlation_id": correlation_id,
+                "parent_minutes_id": minutes_id,
+                "error": str(e)
+            }
+        )
+        raise HTTPException(status_code=500, detail=f"Failed to create new version: {str(e)}")
\ No newline at end of file
diff --git a/app/domain/models.py b/app/domain/models.py
index 03b5b113ab0bd8800796a0333c08b69b21cd0bea..9dc7ea6e58ef2d9ac841a6a365e5a23d8cfa7ea7 100644
--- a/app/domain/models.py
+++ b/app/domain/models.py
@@ -3,6 +3,8 @@ from typing import List, Optional, Literal, Dict, Any
 from pydantic import BaseModel, Field
 from datetime import datetime, timezone
 import uuid
+import hashlib
+import json
 
 Role = Literal["lead", "member"]
 
@@ -201,3 +203,64 @@ class Workshop(BaseModel):
     created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
     started: bool = False
     started_at: Optional[datetime] = None
+
+class MinutesSection(BaseModel):
+    """Structured minutes section with attendees, decisions, actions, and questions"""
+    attendees: List[str] = Field(default_factory=list)
+    decisions: List[str] = Field(default_factory=list)
+    actions: List[str] = Field(default_factory=list)
+    questions: List[str] = Field(default_factory=list)
+
+class Minutes(BaseModel):
+    """Workshop minutes model"""
+    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
+    workshop_id: str
+    status: Literal["draft", "published"] = "draft"
+    sections: MinutesSection = Field(default_factory=MinutesSection)
+    generated_by: Literal["agent", "human"] = "agent"
+    published_at: Optional[datetime] = None
+    content_hash: Optional[str] = None
+    parent_id: Optional[str] = None  # For versioning/revision tracking
+    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
+    updated_by: str = ""
+    
+    def compute_content_hash(self) -> str:
+        """
+        Compute SHA-256 hash of normalized content for immutability verification.
+        Includes sections data and workshop_id for uniqueness.
+        """
+        # Create normalized content for hashing
+        normalized_content = {
+            "workshop_id": self.workshop_id,
+            "sections": {
+                "attendees": sorted(self.sections.attendees),  # Sort for consistency
+                "decisions": sorted(self.sections.decisions),
+                "actions": sorted(self.sections.actions),
+                "questions": sorted(self.sections.questions)
+            }
+        }
+        
+        # Convert to JSON with sorted keys for consistent hashing
+        content_json = json.dumps(normalized_content, sort_keys=True, separators=(',', ':'))
+        
+        # Compute SHA-256 hash
+        return hashlib.sha256(content_json.encode('utf-8')).hexdigest()
+    
+    def validate_content_integrity(self) -> bool:
+        """
+        Validate that current content matches the stored content hash.
+        Returns True if valid or no hash is set (draft state).
+        """
+        if not self.content_hash:
+            return True  # No hash means draft state - always valid
+        
+        current_hash = self.compute_content_hash()
+        return current_hash == self.content_hash
+    
+    def is_published(self) -> bool:
+        """Check if minutes are in published state"""
+        return self.status == "published"
+    
+    def can_edit(self) -> bool:
+        """Check if minutes can be edited (only drafts)"""
+        return self.status == "draft"
diff --git a/app/domain/repository.py b/app/domain/repository.py
index 15eb19ed69d81f332381f193dc01e9ce3db35006..b17b8da13b4d3d27f3ddcbdef2da1237a4ad5f16 100644
--- a/app/domain/repository.py
+++ b/app/domain/repository.py
@@ -2,7 +2,7 @@ from __future__ import annotations
 import threading
 import logging
 from typing import Dict, List, Optional
-from .models import Assessment, Question, Response, Finding, Recommendation, RunLog, Engagement, Membership, Document, Workshop, ConsentRecord
+from .models import Assessment, Question, Response, Finding, Recommendation, RunLog, Engagement, Membership, Document, Workshop, ConsentRecord, Minutes
 
 logger = logging.getLogger(__name__)
 
@@ -38,6 +38,14 @@ class Repository:
     async def list_workshops(self, engagement_id: str, page: int = 1, page_size: int = 50) -> tuple[List[Workshop], int]: ...
     async def update_workshop_consent(self, workshop_id: str, engagement_id: str, attendee_id: str, consent: ConsentRecord) -> Workshop: ...
     async def start_workshop(self, workshop_id: str, engagement_id: str) -> Workshop: ...
+    
+    # Minutes
+    def create_minutes(self, m: Minutes) -> Minutes: ...
+    def get_minutes(self, minutes_id: str) -> Optional[Minutes]: ...
+    def update_minutes(self, m: Minutes) -> Minutes: ...
+    def get_minutes_by_workshop(self, workshop_id: str) -> List[Minutes]: ...
+    def publish_minutes(self, minutes_id: str) -> Minutes: ...
+    def create_new_version(self, parent_id: str, updated_by: str) -> Minutes: ...
 
 class InMemoryRepository(Repository):
     def __init__(self):
@@ -50,6 +58,7 @@ class InMemoryRepository(Repository):
         self.engagements: Dict[str, Engagement] = {}
         self.memberships: Dict[str, Membership] = {}
         self.documents: Dict[str, Document] = {}
+        self.minutes: Dict[str, Minutes] = {}
         # Thread safety lock
         self._lock = threading.RLock()
 
@@ -207,3 +216,80 @@ class InMemoryRepository(Repository):
             # Always remove document from memory even if file deletion failed
             del self.documents[doc_id]
             return True
+    
+    # Minutes methods
+    def create_minutes(self, m: Minutes) -> Minutes:
+        with self._lock:
+            if m.id in self.minutes:
+                raise ValueError(f"Minutes with ID {m.id} already exists")
+            self.minutes[m.id] = m
+            return m
+    
+    def get_minutes(self, minutes_id: str) -> Optional[Minutes]:
+        with self._lock:
+            return self.minutes.get(minutes_id)
+    
+    def update_minutes(self, m: Minutes) -> Minutes:
+        with self._lock:
+            if m.id not in self.minutes:
+                raise ValueError(f"Minutes with ID {m.id} does not exist")
+            self.minutes[m.id] = m
+            return m
+    
+    def get_minutes_by_workshop(self, workshop_id: str) -> List[Minutes]:
+        with self._lock:
+            return [m for m in self.minutes.values() if m.workshop_id == workshop_id]
+    
+    def publish_minutes(self, minutes_id: str) -> Minutes:
+        """Publish minutes - compute hash, set status='published', publishedAt timestamp"""
+        from datetime import datetime, timezone
+        
+        with self._lock:
+            existing_minutes = self.minutes.get(minutes_id)
+            if not existing_minutes:
+                raise ValueError(f"Minutes with ID {minutes_id} not found")
+            
+            if existing_minutes.status != "draft":
+                raise ValueError(f"Can only publish draft minutes. Current status: {existing_minutes.status}")
+            
+            # Create published version with content hash
+            content_hash = existing_minutes.compute_content_hash()
+            published_minutes = Minutes(
+                id=existing_minutes.id,
+                workshop_id=existing_minutes.workshop_id,
+                status="published",
+                sections=existing_minutes.sections,
+                generated_by=existing_minutes.generated_by,
+                published_at=datetime.now(timezone.utc),
+                content_hash=content_hash,
+                parent_id=existing_minutes.parent_id,
+                created_at=existing_minutes.created_at,
+                updated_by=existing_minutes.updated_by
+            )
+            
+            # Store the published minutes
+            self.minutes[minutes_id] = published_minutes
+            return published_minutes
+    
+    def create_new_version(self, parent_id: str, updated_by: str) -> Minutes:
+        """Create new version for editing published minutes"""
+        with self._lock:
+            parent_minutes = self.minutes.get(parent_id)
+            if not parent_minutes:
+                raise ValueError(f"Parent minutes with ID {parent_id} not found")
+            
+            # Create new version as draft with parent reference
+            new_minutes = Minutes(
+                workshop_id=parent_minutes.workshop_id,
+                status="draft",
+                sections=parent_minutes.sections,  # Copy content from parent
+                generated_by="human",  # New version is human-created
+                published_at=None,
+                content_hash=None,  # No hash for drafts
+                parent_id=parent_id,  # Link to parent version
+                updated_by=updated_by
+            )
+            
+            # Store the new version
+            self.minutes[new_minutes.id] = new_minutes
+            return new_minutes
diff --git a/app/repos/cosmos_repository.py b/app/repos/cosmos_repository.py
index b0296ff3be304be73f58e299bce7fa097eb75547..bd708f41d3fa5c7a9454cc4f0e810cf12414982e 100644
--- a/app/repos/cosmos_repository.py
+++ b/app/repos/cosmos_repository.py
@@ -23,7 +23,7 @@ from azure.identity import DefaultAzureCredential
 from domain.models import (
     Assessment, Question, Response, Finding, Recommendation, RunLog,
     Engagement, Membership, Document, EmbeddingDocument, Workshop,
-    WorkshopAttendee, ConsentRecord
+    WorkshopAttendee, ConsentRecord, Minutes
 )
 from domain.repository import Repository
 from api.schemas.gdpr import BackgroundJob, AuditLogEntry, TTLPolicy
@@ -137,6 +137,10 @@ class CosmosRepository(Repository):
             "workshops": {
                 "partition_key": "/engagement_id",
                 "ttl": None  # No TTL for workshop data
+            },
+            "minutes": {
+                "partition_key": "/workshop_id",
+                "ttl": None  # No TTL for minutes data
             }
         }
         
@@ -971,6 +975,247 @@ class CosmosRepository(Repository):
             )
             raise
 
+    # Minutes methods (async implementations for Cosmos DB)
+    def create_minutes(self, m: Minutes) -> Minutes:
+        """Create new minutes (sync wrapper)"""
+        return asyncio.run(self._create_minutes_async(m))
+    
+    def get_minutes(self, minutes_id: str) -> Optional[Minutes]:
+        """Get minutes by ID (sync wrapper)"""
+        # For sync interface, we need the workshop_id - this is a limitation of the sync interface
+        # In practice, this would be called through the async methods in the API routes
+        raise NotImplementedError("Use async get_minutes_async method with workshop_id")
+    
+    def update_minutes(self, m: Minutes) -> Minutes:
+        """Update existing minutes (sync wrapper)"""
+        return asyncio.run(self._update_minutes_async(m))
+    
+    def get_minutes_by_workshop(self, workshop_id: str) -> List[Minutes]:
+        """Get all minutes for a workshop (sync wrapper)"""
+        return asyncio.run(self._get_minutes_by_workshop_async(workshop_id))
+    
+    async def _create_minutes_async(self, m: Minutes) -> Minutes:
+        """Create new minutes"""
+        try:
+            minutes_dict = m.model_dump()
+            minutes_dict["id"] = m.id
+            
+            stored_item = await self._upsert_item("minutes", minutes_dict)
+            return Minutes(**stored_item)
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to create minutes: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "minutes_id": m.id,
+                    "workshop_id": m.workshop_id,
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    async def get_minutes_async(self, minutes_id: str, workshop_id: str) -> Optional[Minutes]:
+        """Get minutes by ID"""
+        try:
+            item = await self._get_item("minutes", minutes_id, workshop_id)
+            return Minutes(**item) if item else None
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to get minutes: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "minutes_id": minutes_id,
+                    "workshop_id": workshop_id,
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    async def _update_minutes_async(self, m: Minutes) -> Minutes:
+        """Update existing minutes"""
+        try:
+            minutes_dict = m.model_dump()
+            minutes_dict["id"] = m.id
+            
+            stored_item = await self._upsert_item("minutes", minutes_dict)
+            return Minutes(**stored_item)
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to update minutes: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "minutes_id": m.id,
+                    "workshop_id": m.workshop_id,
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    async def _get_minutes_by_workshop_async(self, workshop_id: str) -> List[Minutes]:
+        """Get all minutes for a workshop"""
+        try:
+            query = "SELECT * FROM c WHERE c.workshop_id = @workshop_id ORDER BY c.created_at DESC"
+            parameters = [{"name": "@workshop_id", "value": workshop_id}]
+            
+            items = await self._query_items("minutes", query, parameters, workshop_id)
+            return [Minutes(**item) for item in items]
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to get minutes by workshop: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "workshop_id": workshop_id,
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    def publish_minutes(self, minutes_id: str) -> Minutes:
+        """Publish minutes (compute hash, set status='published', publishedAt timestamp)"""
+        return asyncio.run(self._publish_minutes_async(minutes_id))
+    
+    async def _publish_minutes_async(self, minutes_id: str) -> Minutes:
+        """Publish minutes - async implementation"""
+        try:
+            # First, get the existing minutes to determine workshop_id
+            # We need to query by minutes_id across all workshops
+            query = "SELECT * FROM c WHERE c.id = @minutes_id"
+            parameters = [{"name": "@minutes_id", "value": minutes_id}]
+            
+            # Query without partition key - this requires cross-partition query
+            container = self.containers.get("minutes")
+            if not container:
+                raise ValueError("Minutes container not available")
+            
+            items = list(container.query_items(
+                query=query,
+                parameters=parameters,
+                enable_cross_partition_query=True
+            ))
+            
+            if not items:
+                raise ValueError(f"Minutes with ID {minutes_id} not found")
+            
+            minutes = Minutes(**items[0])
+            
+            # Validate that minutes are in draft state
+            if minutes.status != "draft":
+                raise ValueError(f"Can only publish draft minutes. Current status: {minutes.status}")
+            
+            # Compute content hash and update to published status
+            content_hash = minutes.compute_content_hash()
+            published_minutes = Minutes(
+                id=minutes.id,
+                workshop_id=minutes.workshop_id,
+                status="published",
+                sections=minutes.sections,
+                generated_by=minutes.generated_by,
+                published_at=datetime.now(timezone.utc),
+                content_hash=content_hash,
+                parent_id=minutes.parent_id,
+                created_at=minutes.created_at,
+                updated_by=minutes.updated_by
+            )
+            
+            # Store the published minutes
+            stored_item = await self._upsert_item("minutes", published_minutes.model_dump())
+            result_minutes = Minutes(**stored_item)
+            
+            logger.info(
+                "Successfully published minutes",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "minutes_id": minutes_id,
+                    "workshop_id": minutes.workshop_id,
+                    "content_hash": content_hash,
+                    "published_at": result_minutes.published_at
+                }
+            )
+            
+            return result_minutes
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to publish minutes: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "minutes_id": minutes_id,
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    def create_new_version(self, parent_id: str, updated_by: str) -> Minutes:
+        """Create new version for editing published minutes"""
+        return asyncio.run(self._create_new_version_async(parent_id, updated_by))
+    
+    async def _create_new_version_async(self, parent_id: str, updated_by: str) -> Minutes:
+        """Create new version - async implementation"""
+        try:
+            # Get the parent minutes
+            query = "SELECT * FROM c WHERE c.id = @parent_id"
+            parameters = [{"name": "@parent_id", "value": parent_id}]
+            
+            container = self.containers.get("minutes")
+            if not container:
+                raise ValueError("Minutes container not available")
+            
+            items = list(container.query_items(
+                query=query,
+                parameters=parameters,
+                enable_cross_partition_query=True
+            ))
+            
+            if not items:
+                raise ValueError(f"Parent minutes with ID {parent_id} not found")
+            
+            parent_minutes = Minutes(**items[0])
+            
+            # Create new version as draft with parent reference
+            new_minutes = Minutes(
+                workshop_id=parent_minutes.workshop_id,
+                status="draft",
+                sections=parent_minutes.sections,  # Copy content from parent
+                generated_by="human",  # New version is human-created
+                published_at=None,
+                content_hash=None,  # No hash for drafts
+                parent_id=parent_id,  # Link to parent version
+                updated_by=updated_by
+            )
+            
+            # Store the new version
+            stored_item = await self._upsert_item("minutes", new_minutes.model_dump())
+            result_minutes = Minutes(**stored_item)
+            
+            logger.info(
+                "Successfully created new minutes version",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "new_minutes_id": result_minutes.id,
+                    "parent_id": parent_id,
+                    "workshop_id": result_minutes.workshop_id,
+                    "updated_by": updated_by
+                }
+            )
+            
+            return result_minutes
+            
+        except Exception as e:
+            logger.error(
+                f"Failed to create new minutes version: {str(e)}",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "parent_id": parent_id,
+                    "updated_by": updated_by,
+                    "error": str(e)
+                }
+            )
+            raise
+
 
 # Factory function
 def create_cosmos_repository(correlation_id: Optional[str] = None) -> CosmosRepository:
diff --git a/app/services/minutes_agent.py b/app/services/minutes_agent.py
new file mode 100644
index 0000000000000000000000000000000000000000..9ddd4344d29694c1b239c4d2b5043b22263c37f3
--- /dev/null
+++ b/app/services/minutes_agent.py
@@ -0,0 +1,152 @@
+"""
+Minutes Agent Service
+
+Generates structured minutes from workshop data using AI agents.
+S4 implementation provides deterministic stub functionality.
+"""
+
+import logging
+from typing import Dict, Any, Optional
+from datetime import datetime
+
+from domain.models import MinutesSection, Minutes
+
+logger = logging.getLogger(__name__)
+
+
+class MinutesAgent:
+    """AI agent for generating structured workshop minutes"""
+    
+    def __init__(self, correlation_id: Optional[str] = None):
+        self.correlation_id = correlation_id or "minutes-agent"
+    
+    async def generate_draft_minutes(self, workshop: Dict[str, Any]) -> MinutesSection:
+        """
+        Generate draft minutes from workshop data.
+        S4 stub implementation with deterministic outputs.
+        
+        Args:
+            workshop: Workshop data containing participants, discussions, etc.
+            
+        Returns:
+            MinutesSection with structured content
+        """
+        logger.info(
+            "Generating draft minutes",
+            extra={
+                "correlation_id": self.correlation_id,
+                "workshop_id": workshop.get("id", "unknown"),
+                "workshop_type": workshop.get("type", "unknown")
+            }
+        )
+        
+        try:
+            # S4 Stub: Generate deterministic structured content
+            attendees = self._extract_attendees(workshop)
+            decisions = self._generate_decisions(workshop)
+            actions = self._generate_actions(workshop)
+            questions = self._generate_questions(workshop)
+            
+            minutes_section = MinutesSection(
+                attendees=attendees,
+                decisions=decisions,
+                actions=actions,
+                questions=questions
+            )
+            
+            logger.info(
+                "Successfully generated draft minutes",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "workshop_id": workshop.get("id", "unknown"),
+                    "attendee_count": len(attendees),
+                    "decision_count": len(decisions),
+                    "action_count": len(actions),
+                    "question_count": len(questions)
+                }
+            )
+            
+            return minutes_section
+            
+        except Exception as e:
+            logger.error(
+                "Failed to generate draft minutes",
+                extra={
+                    "correlation_id": self.correlation_id,
+                    "workshop_id": workshop.get("id", "unknown"),
+                    "error": str(e)
+                }
+            )
+            raise
+    
+    def _extract_attendees(self, workshop: Dict[str, Any]) -> list[str]:
+        """Extract attendees from workshop data (S4 stub implementation)"""
+        # Stub: Look for attendees in workshop data or generate defaults
+        if "attendees" in workshop:
+            return workshop["attendees"]
+        
+        if "participants" in workshop:
+            return workshop["participants"]
+        
+        # Default stub attendees
+        return [
+            "Workshop Facilitator",
+            "Technical Lead",
+            "Security Analyst",
+            "Stakeholder Representative"
+        ]
+    
+    def _generate_decisions(self, workshop: Dict[str, Any]) -> list[str]:
+        """Generate decisions from workshop data (S4 stub implementation)"""
+        workshop_type = workshop.get("type", "general")
+        
+        # Stub decisions based on workshop type
+        if workshop_type.lower() in ["security", "assessment"]:
+            return [
+                "Approved implementation of multi-factor authentication",
+                "Decided to conduct quarterly security training",
+                "Agreed on risk assessment timeline"
+            ]
+        
+        return [
+            "Approved project roadmap for next quarter",
+            "Decided to implement automated testing pipeline",
+            "Agreed on weekly status meetings"
+        ]
+    
+    def _generate_actions(self, workshop: Dict[str, Any]) -> list[str]:
+        """Generate action items from workshop data (S4 stub implementation)"""
+        return [
+            "Technical Lead to create detailed implementation plan by end of week",
+            "Security Analyst to review compliance requirements by Friday",
+            "Stakeholder Representative to update executive team on progress",
+            "Workshop Facilitator to schedule follow-up meeting in 2 weeks"
+        ]
+    
+    def _generate_questions(self, workshop: Dict[str, Any]) -> list[str]:
+        """Generate open questions from workshop data (S4 stub implementation)"""
+        return [
+            "What is the expected timeline for budget approval?",
+            "How will we measure success of implemented changes?",
+            "What additional resources may be needed for implementation?",
+            "Are there any regulatory considerations we haven't addressed?"
+        ]
+
+
+def compute_content_hash(minutes: Minutes) -> str:
+    """
+    Compute SHA-256 hash of normalized content for immutability verification.
+    Uses the Minutes model's built-in computation method.
+    """
+    return minutes.compute_content_hash()
+
+def validate_content_integrity(minutes: Minutes) -> bool:
+    """
+    Validate that current content matches the stored content hash.
+    Uses the Minutes model's built-in validation method.
+    """
+    return minutes.validate_content_integrity()
+
+def create_minutes_agent(correlation_id: Optional[str] = None) -> MinutesAgent:
+    """Factory function to create MinutesAgent instance"""
+    return MinutesAgent(correlation_id=correlation_id)
\ No newline at end of file
diff --git a/app/tests/test_minutes.py b/app/tests/test_minutes.py
new file mode 100644
index 0000000000000000000000000000000000000000..903e5182a3d4b83e237b8b6b19e86d1fb34e5aae
--- /dev/null
+++ b/app/tests/test_minutes.py
@@ -0,0 +1,843 @@
+"""
+Comprehensive tests for Minutes Agent functionality.
+
+Tests cover:
+- Domain models (Minutes, MinutesSection)
+- Repository operations (create, get, update)
+- Minutes agent service
+- API endpoints with security
+"""
+
+import pytest
+import json
+from datetime import datetime, timezone
+from unittest.mock import Mock, AsyncMock, patch
+from fastapi import HTTPException
+from fastapi.testclient import TestClient
+
+from domain.models import Minutes, MinutesSection
+from domain.repository import InMemoryRepository
+from services.minutes_agent import MinutesAgent, create_minutes_agent
+from api.routes.minutes import router as minutes_router
+from fastapi import FastAPI
+
+
+# Test fixtures
+@pytest.fixture
+def sample_minutes_section():
+    """Sample minutes section for testing"""
+    return MinutesSection(
+        attendees=["Alice Smith", "Bob Jones", "Carol Wilson"],
+        decisions=["Approved security upgrade", "Set monthly review meetings"],
+        actions=["Alice to draft proposal by Friday", "Bob to review compliance"],
+        questions=["What's the budget for implementation?", "Timeline for rollout?"]
+    )
+
+@pytest.fixture
+def sample_minutes(sample_minutes_section):
+    """Sample minutes for testing"""
+    return Minutes(
+        workshop_id="workshop-123",
+        status="draft",
+        sections=sample_minutes_section,
+        generated_by="agent",
+        updated_by="test@example.com"
+    )
+
+@pytest.fixture
+def sample_workshop_data():
+    """Sample workshop data for agent testing"""
+    return {
+        "id": "workshop-123",
+        "type": "security",
+        "attendees": ["Alice Smith", "Bob Jones"],
+        "additional_context": {"topic": "Security Assessment"}
+    }
+
+@pytest.fixture
+def in_memory_repo():
+    """In-memory repository for testing"""
+    return InMemoryRepository()
+
+@pytest.fixture
+def minutes_agent():
+    """Minutes agent instance for testing"""
+    return create_minutes_agent("test-correlation-id")
+
+@pytest.fixture
+def mock_security_context():
+    """Mock security context for API tests"""
+    return {
+        "user_email": "test@example.com",
+        "engagement_id": "engagement-123",
+        "tenant_id": None,
+        "aad_groups_enabled": False,
+        "aad_groups": [],
+        "aad_roles": [],
+        "is_aad_admin": False,
+        "tenant_validated": True
+    }
+
+
+# Domain Model Tests
+class TestMinutesModels:
+    
+    def test_minutes_section_creation(self):
+        """Test MinutesSection model creation and defaults"""
+        section = MinutesSection()
+        
+        assert section.attendees == []
+        assert section.decisions == []
+        assert section.actions == []
+        assert section.questions == []
+    
+    def test_minutes_section_with_data(self, sample_minutes_section):
+        """Test MinutesSection with sample data"""
+        assert len(sample_minutes_section.attendees) == 3
+        assert len(sample_minutes_section.decisions) == 2
+        assert len(sample_minutes_section.actions) == 2
+        assert len(sample_minutes_section.questions) == 2
+    
+    def test_minutes_creation(self, sample_minutes):
+        """Test Minutes model creation"""
+        assert sample_minutes.workshop_id == "workshop-123"
+        assert sample_minutes.status == "draft"
+        assert sample_minutes.generated_by == "agent"
+        assert sample_minutes.updated_by == "test@example.com"
+        assert sample_minutes.published_at is None
+        assert isinstance(sample_minutes.created_at, datetime)
+        assert sample_minutes.id  # Should have auto-generated ID
+    
+    def test_minutes_serialization(self, sample_minutes):
+        """Test Minutes model serialization"""
+        data = sample_minutes.model_dump()
+        
+        assert data["workshop_id"] == "workshop-123"
+        assert data["status"] == "draft"
+        assert "sections" in data
+        assert "attendees" in data["sections"]
+
+
+# Repository Tests
+class TestMinutesRepository:
+    
+    def test_create_minutes(self, in_memory_repo, sample_minutes):
+        """Test creating minutes in repository"""
+        result = in_memory_repo.create_minutes(sample_minutes)
+        
+        assert result.id == sample_minutes.id
+        assert result.workshop_id == sample_minutes.workshop_id
+        assert result.status == sample_minutes.status
+    
+    def test_create_duplicate_minutes_fails(self, in_memory_repo, sample_minutes):
+        """Test that creating duplicate minutes fails"""
+        in_memory_repo.create_minutes(sample_minutes)
+        
+        with pytest.raises(ValueError, match="Minutes with ID .* already exists"):
+            in_memory_repo.create_minutes(sample_minutes)
+    
+    def test_get_minutes(self, in_memory_repo, sample_minutes):
+        """Test getting minutes by ID"""
+        in_memory_repo.create_minutes(sample_minutes)
+        
+        result = in_memory_repo.get_minutes(sample_minutes.id)
+        
+        assert result is not None
+        assert result.id == sample_minutes.id
+        assert result.workshop_id == sample_minutes.workshop_id
+    
+    def test_get_nonexistent_minutes(self, in_memory_repo):
+        """Test getting non-existent minutes returns None"""
+        result = in_memory_repo.get_minutes("nonexistent-id")
+        assert result is None
+    
+    def test_update_minutes(self, in_memory_repo, sample_minutes, sample_minutes_section):
+        """Test updating existing minutes"""
+        # Create original
+        in_memory_repo.create_minutes(sample_minutes)
+        
+        # Update
+        updated_minutes = Minutes(
+            id=sample_minutes.id,
+            workshop_id=sample_minutes.workshop_id,
+            status="published",
+            sections=sample_minutes_section,
+            generated_by="human",
+            updated_by="editor@example.com",
+            created_at=sample_minutes.created_at
+        )
+        
+        result = in_memory_repo.update_minutes(updated_minutes)
+        
+        assert result.status == "published"
+        assert result.generated_by == "human"
+        assert result.updated_by == "editor@example.com"
+    
+    def test_update_nonexistent_minutes_fails(self, in_memory_repo, sample_minutes):
+        """Test updating non-existent minutes fails"""
+        with pytest.raises(ValueError, match="Minutes with ID .* does not exist"):
+            in_memory_repo.update_minutes(sample_minutes)
+    
+    def test_get_minutes_by_workshop(self, in_memory_repo, sample_minutes_section):
+        """Test getting all minutes for a workshop"""
+        workshop_id = "workshop-123"
+        
+        # Create multiple minutes for same workshop
+        minutes1 = Minutes(
+            workshop_id=workshop_id,
+            sections=sample_minutes_section,
+            updated_by="user1@example.com"
+        )
+        minutes2 = Minutes(
+            workshop_id=workshop_id,
+            sections=sample_minutes_section,
+            updated_by="user2@example.com"
+        )
+        # Different workshop
+        minutes3 = Minutes(
+            workshop_id="other-workshop",
+            sections=sample_minutes_section,
+            updated_by="user3@example.com"
+        )
+        
+        in_memory_repo.create_minutes(minutes1)
+        in_memory_repo.create_minutes(minutes2)
+        in_memory_repo.create_minutes(minutes3)
+        
+        result = in_memory_repo.get_minutes_by_workshop(workshop_id)
+        
+        assert len(result) == 2
+        assert all(m.workshop_id == workshop_id for m in result)
+
+
+# Minutes Agent Service Tests
+class TestMinutesAgent:
+    
+    @pytest.mark.asyncio
+    async def test_generate_draft_minutes_basic(self, minutes_agent, sample_workshop_data):
+        """Test basic draft minutes generation"""
+        result = await minutes_agent.generate_draft_minutes(sample_workshop_data)
+        
+        assert isinstance(result, MinutesSection)
+        assert len(result.attendees) > 0
+        assert len(result.decisions) > 0
+        assert len(result.actions) > 0
+        assert len(result.questions) > 0
+    
+    @pytest.mark.asyncio
+    async def test_generate_security_workshop_minutes(self, minutes_agent):
+        """Test minutes generation for security workshop"""
+        workshop_data = {
+            "id": "sec-workshop-456",
+            "type": "security",
+            "attendees": ["Security Lead", "Compliance Officer"]
+        }
+        
+        result = await minutes_agent.generate_draft_minutes(workshop_data)
+        
+        # Should have security-specific content
+        decisions = " ".join(result.decisions).lower()
+        assert "security" in decisions or "authentication" in decisions or "risk" in decisions
+    
+    @pytest.mark.asyncio
+    async def test_extract_attendees_from_workshop(self, minutes_agent):
+        """Test attendees extraction from workshop data"""
+        workshop_data = {
+            "id": "workshop-789",
+            "attendees": ["Custom Attendee 1", "Custom Attendee 2"]
+        }
+        
+        result = await minutes_agent.generate_draft_minutes(workshop_data)
+        
+        assert "Custom Attendee 1" in result.attendees
+        assert "Custom Attendee 2" in result.attendees
+    
+    @pytest.mark.asyncio
+    async def test_generate_with_participants_key(self, minutes_agent):
+        """Test extraction when workshop uses 'participants' key"""
+        workshop_data = {
+            "id": "workshop-participants",
+            "participants": ["Participant 1", "Participant 2"]
+        }
+        
+        result = await minutes_agent.generate_draft_minutes(workshop_data)
+        
+        assert "Participant 1" in result.attendees
+        assert "Participant 2" in result.attendees
+    
+    @pytest.mark.asyncio
+    async def test_generate_with_no_attendees(self, minutes_agent):
+        """Test generation with default attendees when none provided"""
+        workshop_data = {"id": "workshop-no-attendees"}
+        
+        result = await minutes_agent.generate_draft_minutes(workshop_data)
+        
+        # Should have default attendees
+        assert len(result.attendees) >= 4
+        assert "Workshop Facilitator" in result.attendees
+    
+    def test_create_minutes_agent_factory(self):
+        """Test minutes agent factory function"""
+        agent = create_minutes_agent("test-correlation")
+        
+        assert isinstance(agent, MinutesAgent)
+        assert agent.correlation_id == "test-correlation"
+
+
+# API Endpoint Tests
+class TestMinutesAPI:
+    
+    @pytest.fixture
+    def app_with_minutes(self):
+        """FastAPI app with minutes router for testing"""
+        app = FastAPI()
+        app.include_router(minutes_router)
+        
+        # Mock repository
+        mock_repo = Mock(spec=InMemoryRepository)
+        app.state.repo = mock_repo
+        
+        return app, mock_repo
+    
+    @pytest.fixture
+    def client(self, app_with_minutes):
+        """Test client for API endpoints"""
+        app, mock_repo = app_with_minutes
+        return TestClient(app), mock_repo
+    
+    def test_generate_minutes_requires_auth(self, client):
+        """Test that generate minutes endpoint requires authentication"""
+        test_client, _ = client
+        
+        response = test_client.post(
+            "/api/v1/workshops/test-workshop/minutes:generate",
+            json={"workshop_type": "security"}
+        )
+        
+        # Should fail due to missing headers
+        assert response.status_code == 422  # Validation error for missing headers
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    @patch('api.routes.minutes.create_minutes_agent')
+    def test_generate_minutes_success(
+        self, 
+        mock_create_agent, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes_section,
+        mock_security_context
+    ):
+        """Test successful minutes generation"""
+        test_client, mock_repo = client
+        
+        # Mock security context
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None  # Success
+        
+        # Mock agent
+        mock_agent = Mock()
+        mock_agent.generate_draft_minutes = AsyncMock(return_value=sample_minutes_section)
+        mock_create_agent.return_value = mock_agent
+        
+        # Mock repository
+        mock_minutes = Minutes(
+            workshop_id="test-workshop",
+            sections=sample_minutes_section,
+            updated_by=mock_security_context["user_email"]
+        )
+        mock_repo.create_minutes.return_value = mock_minutes
+        
+        response = test_client.post(
+            "/api/v1/workshops/test-workshop/minutes:generate",
+            json={"workshop_type": "security"},
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 200
+        data = response.json()
+        assert data["workshop_id"] == "test-workshop"
+        assert data["status"] == "draft"
+        assert data["generated_by"] == "agent"
+        assert "sections" in data
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_generate_minutes_member_check_failure(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        mock_security_context
+    ):
+        """Test minutes generation with membership check failure"""
+        test_client, _ = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.side_effect = HTTPException(status_code=403, detail="Not a member")
+        
+        response = test_client.post(
+            "/api/v1/workshops/test-workshop/minutes:generate",
+            json={"workshop_type": "security"},
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 403
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_update_draft_minutes_only(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes_section,
+        mock_security_context
+    ):
+        """Test that only draft minutes can be updated"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        
+        # Mock existing published minutes
+        existing_minutes = Minutes(
+            id="minutes-123",
+            workshop_id="test-workshop",
+            status="published",  # Not draft
+            sections=sample_minutes_section,
+            updated_by="original@example.com"
+        )
+        mock_repo.get_minutes.return_value = existing_minutes
+        
+        response = test_client.patch(
+            "/api/v1/minutes/minutes-123",
+            json={"sections": sample_minutes_section.model_dump()},
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 403
+        assert "draft minutes" in response.json()["detail"]
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_get_minutes_success(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes,
+        mock_security_context
+    ):
+        """Test successful retrieval of minutes"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        mock_repo.get_minutes.return_value = sample_minutes
+        
+        response = test_client.get(
+            f"/api/v1/minutes/{sample_minutes.id}",
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 200
+        data = response.json()
+        assert data["id"] == sample_minutes.id
+        assert data["workshop_id"] == sample_minutes.workshop_id
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_get_nonexistent_minutes(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        mock_security_context
+    ):
+        """Test retrieval of non-existent minutes"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        mock_repo.get_minutes.return_value = None
+        
+        response = test_client.get(
+            "/api/v1/minutes/nonexistent-id",
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 404
+
+
+# Integration Tests
+class TestMinutesIntegration:
+    
+    @pytest.mark.asyncio
+    async def test_end_to_end_minutes_workflow(self, in_memory_repo, minutes_agent, sample_workshop_data):
+        """Test complete workflow: generate -> store -> retrieve -> update"""
+        
+        # 1. Generate minutes using agent
+        sections = await minutes_agent.generate_draft_minutes(sample_workshop_data)
+        
+        # 2. Create minutes in repository
+        minutes = Minutes(
+            workshop_id=sample_workshop_data["id"],
+            sections=sections,
+            updated_by="workflow@example.com"
+        )
+        stored_minutes = in_memory_repo.create_minutes(minutes)
+        
+        # 3. Retrieve minutes
+        retrieved_minutes = in_memory_repo.get_minutes(stored_minutes.id)
+        assert retrieved_minutes is not None
+        assert retrieved_minutes.status == "draft"
+        
+        # 4. Update minutes to published
+        updated_minutes = Minutes(
+            id=retrieved_minutes.id,
+            workshop_id=retrieved_minutes.workshop_id,
+            status="published",
+            sections=retrieved_minutes.sections,
+            generated_by="human",
+            updated_by="publisher@example.com",
+            created_at=retrieved_minutes.created_at,
+            published_at=datetime.now(timezone.utc)
+        )
+        
+        final_minutes = in_memory_repo.update_minutes(updated_minutes)
+        assert final_minutes.status == "published"
+        assert final_minutes.generated_by == "human"
+        assert final_minutes.published_at is not None
+    
+    def test_minutes_cross_engagement_security(self, in_memory_repo, sample_minutes_section):
+        """Test that minutes are properly scoped by workshop/engagement"""
+        
+        # Create minutes for different workshops
+        minutes1 = Minutes(
+            workshop_id="engagement-1-workshop",
+            sections=sample_minutes_section,
+            updated_by="user1@example.com"
+        )
+        minutes2 = Minutes(
+            workshop_id="engagement-2-workshop", 
+            sections=sample_minutes_section,
+            updated_by="user2@example.com"
+        )
+        
+        in_memory_repo.create_minutes(minutes1)
+        in_memory_repo.create_minutes(minutes2)
+        
+        # Should only get minutes for specific workshop
+        workshop1_minutes = in_memory_repo.get_minutes_by_workshop("engagement-1-workshop")
+        workshop2_minutes = in_memory_repo.get_minutes_by_workshop("engagement-2-workshop")
+        
+        assert len(workshop1_minutes) == 1
+        assert len(workshop2_minutes) == 1
+        assert workshop1_minutes[0].id != workshop2_minutes[0].id
+
+
+# Publish Workflow Tests
+class TestMinutesPublishWorkflow:
+    
+    def test_content_hash_computation(self, sample_minutes):
+        """Test content hash computation for immutability"""
+        hash1 = sample_minutes.compute_content_hash()
+        hash2 = sample_minutes.compute_content_hash()
+        
+        # Same content should produce same hash
+        assert hash1 == hash2
+        assert len(hash1) == 64  # SHA-256 hex length
+    
+    def test_content_hash_changes_with_content(self, sample_minutes, sample_minutes_section):
+        """Test that content hash changes when content changes"""
+        original_hash = sample_minutes.compute_content_hash()
+        
+        # Modify content
+        new_section = MinutesSection(
+            attendees=sample_minutes_section.attendees + ["New Attendee"],
+            decisions=sample_minutes_section.decisions,
+            actions=sample_minutes_section.actions,
+            questions=sample_minutes_section.questions
+        )
+        
+        modified_minutes = Minutes(
+            id=sample_minutes.id,
+            workshop_id=sample_minutes.workshop_id,
+            status=sample_minutes.status,
+            sections=new_section,
+            generated_by=sample_minutes.generated_by,
+            updated_by=sample_minutes.updated_by,
+            created_at=sample_minutes.created_at
+        )
+        
+        modified_hash = modified_minutes.compute_content_hash()
+        assert original_hash != modified_hash
+    
+    def test_content_integrity_validation(self, sample_minutes):
+        """Test content integrity validation"""
+        # Draft minutes without hash should be valid
+        assert sample_minutes.validate_content_integrity() == True
+        
+        # Set content hash
+        content_hash = sample_minutes.compute_content_hash()
+        sample_minutes.content_hash = content_hash
+        
+        # Should still be valid
+        assert sample_minutes.validate_content_integrity() == True
+        
+        # Tamper with hash
+        sample_minutes.content_hash = "invalid_hash"
+        assert sample_minutes.validate_content_integrity() == False
+    
+    def test_publish_minutes_workflow(self, in_memory_repo, sample_minutes):
+        """Test the complete publish workflow"""
+        # Create draft minutes
+        stored_minutes = in_memory_repo.create_minutes(sample_minutes)
+        assert stored_minutes.status == "draft"
+        assert stored_minutes.content_hash is None
+        
+        # Publish minutes
+        published_minutes = in_memory_repo.publish_minutes(stored_minutes.id)
+        
+        assert published_minutes.status == "published"
+        assert published_minutes.content_hash is not None
+        assert published_minutes.published_at is not None
+        assert len(published_minutes.content_hash) == 64  # SHA-256 hex
+    
+    def test_publish_only_draft_minutes(self, in_memory_repo, sample_minutes):
+        """Test that only draft minutes can be published"""
+        # Create and publish minutes first
+        stored_minutes = in_memory_repo.create_minutes(sample_minutes)
+        published_minutes = in_memory_repo.publish_minutes(stored_minutes.id)
+        
+        # Try to publish again - should fail
+        with pytest.raises(ValueError, match="Can only publish draft minutes"):
+            in_memory_repo.publish_minutes(published_minutes.id)
+    
+    def test_editing_published_minutes_fails(self, in_memory_repo, sample_minutes):
+        """Test that published minutes cannot be edited"""
+        # Create and publish minutes
+        stored_minutes = in_memory_repo.create_minutes(sample_minutes)
+        published_minutes = in_memory_repo.publish_minutes(stored_minutes.id)
+        
+        # Try to edit published minutes - should fail
+        modified_minutes = Minutes(
+            id=published_minutes.id,
+            workshop_id=published_minutes.workshop_id,
+            status="published",
+            sections=published_minutes.sections,
+            generated_by="human",
+            updated_by="editor@example.com",
+            created_at=published_minutes.created_at
+        )
+        
+        # The update should work but API layer should prevent this
+        # Here we test that the can_edit() method works correctly
+        assert not published_minutes.can_edit()
+        assert published_minutes.is_published()
+    
+    def test_create_new_version_workflow(self, in_memory_repo, sample_minutes):
+        """Test creating new version for editing published minutes"""
+        # Create and publish original
+        stored_minutes = in_memory_repo.create_minutes(sample_minutes)
+        published_minutes = in_memory_repo.publish_minutes(stored_minutes.id)
+        
+        # Create new version
+        new_version = in_memory_repo.create_new_version(published_minutes.id, "editor@example.com")
+        
+        # Verify new version properties
+        assert new_version.id != published_minutes.id
+        assert new_version.workshop_id == published_minutes.workshop_id
+        assert new_version.status == "draft"
+        assert new_version.parent_id == published_minutes.id
+        assert new_version.generated_by == "human"
+        assert new_version.updated_by == "editor@example.com"
+        assert new_version.content_hash is None
+        assert new_version.published_at is None
+        
+        # Content should be copied from parent
+        assert new_version.sections.attendees == published_minutes.sections.attendees
+        assert new_version.sections.decisions == published_minutes.sections.decisions
+    
+    def test_version_chain_integrity(self, in_memory_repo, sample_minutes):
+        """Test that version chains maintain proper relationships"""
+        # Create original -> publish -> create new version -> publish -> create another version
+        original = in_memory_repo.create_minutes(sample_minutes)
+        published_v1 = in_memory_repo.publish_minutes(original.id)
+        
+        draft_v2 = in_memory_repo.create_new_version(published_v1.id, "editor1@example.com")
+        published_v2 = in_memory_repo.publish_minutes(draft_v2.id)
+        
+        draft_v3 = in_memory_repo.create_new_version(published_v2.id, "editor2@example.com")
+        
+        # Verify chain
+        assert original.parent_id is None  # Original has no parent
+        assert published_v1.id == original.id  # Same record, just published
+        assert draft_v2.parent_id == published_v1.id
+        assert published_v2.id == draft_v2.id  # Same record, just published
+        assert draft_v3.parent_id == published_v2.id
+
+
+# API Tests for Publish Functionality
+class TestPublishAPI:
+    
+    @pytest.fixture
+    def app_with_minutes(self):
+        """FastAPI app with minutes router for testing"""
+        app = FastAPI()
+        app.include_router(minutes_router)
+        
+        # Mock repository
+        mock_repo = Mock(spec=InMemoryRepository)
+        app.state.repo = mock_repo
+        
+        return app, mock_repo
+    
+    @pytest.fixture
+    def client(self, app_with_minutes):
+        """Test client for API endpoints"""
+        app, mock_repo = app_with_minutes
+        return TestClient(app), mock_repo
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_publish_minutes_endpoint(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes,
+        mock_security_context
+    ):
+        """Test the publish minutes API endpoint"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        
+        # Mock published minutes result
+        published_minutes = Minutes(
+            id=sample_minutes.id,
+            workshop_id=sample_minutes.workshop_id,
+            status="published",
+            sections=sample_minutes.sections,
+            generated_by=sample_minutes.generated_by,
+            published_at=datetime.now(timezone.utc),
+            content_hash="abc123",
+            updated_by=sample_minutes.updated_by,
+            created_at=sample_minutes.created_at
+        )
+        mock_repo.publish_minutes.return_value = published_minutes
+        
+        response = test_client.post(
+            f"/api/v1/minutes/{sample_minutes.id}:publish",
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 200
+        data = response.json()
+        assert data["status"] == "published"
+        assert data["content_hash"] == "abc123"
+        assert data["published_at"] is not None
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_create_new_version_endpoint(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes,
+        mock_security_context
+    ):
+        """Test the create new version API endpoint"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        
+        # Mock new version result
+        new_version = Minutes(
+            workshop_id=sample_minutes.workshop_id,
+            status="draft",
+            sections=sample_minutes.sections,
+            generated_by="human",
+            parent_id=sample_minutes.id,
+            updated_by="test@example.com"
+        )
+        mock_repo.create_new_version.return_value = new_version
+        
+        response = test_client.post(
+            f"/api/v1/minutes/{sample_minutes.id}/versions/new",
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 200
+        data = response.json()
+        assert data["status"] == "draft"
+        assert data["parent_id"] == sample_minutes.id
+        assert data["generated_by"] == "human"
+        assert data["updated_by"] == "test@example.com"
+    
+    @patch('api.routes.minutes.current_context')
+    @patch('api.routes.minutes.require_member')
+    def test_patch_published_minutes_returns_409(
+        self, 
+        mock_require_member, 
+        mock_current_context,
+        client,
+        sample_minutes_section,
+        mock_security_context
+    ):
+        """Test that PATCH returns 409 for published minutes with guidance"""
+        test_client, mock_repo = client
+        
+        mock_current_context.return_value = mock_security_context
+        mock_require_member.return_value = None
+        
+        # Mock existing published minutes
+        published_minutes = Minutes(
+            id="minutes-123",
+            workshop_id="test-workshop",
+            status="published",
+            sections=sample_minutes_section,
+            updated_by="original@example.com"
+        )
+        mock_repo.get_minutes.return_value = published_minutes
+        
+        response = test_client.patch(
+            "/api/v1/minutes/minutes-123",
+            json={"sections": sample_minutes_section.model_dump()},
+            headers={
+                "X-User-Email": "test@example.com",
+                "X-Engagement-ID": "engagement-123"
+            }
+        )
+        
+        assert response.status_code == 409
+        detail = response.json()["detail"]
+        assert "Cannot edit published minutes" in detail
+        assert "/versions/new" in detail  # Should guide to new version endpoint
\ No newline at end of file
diff --git a/web/app/e/[engagementId]/workshops/[id]/minutes/page.tsx b/web/app/e/[engagementId]/workshops/[id]/minutes/page.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..99cae2c7a7f0e7d94bd46452512da441a160e4c6
--- /dev/null
+++ b/web/app/e/[engagementId]/workshops/[id]/minutes/page.tsx
@@ -0,0 +1,288 @@
+'use client';
+
+import { useState, useEffect } from 'react';
+import { useParams, useRouter, useSearchParams } from 'next/navigation';
+import { 
+  getMinutes, 
+  updateMinutes, 
+  publishMinutes, 
+  createNewVersion, 
+  MinutesConflictError 
+} from '../../../../../../lib/minutes';
+import { Minutes, MinutesSection } from '../../../../../../types/minutes';
+
+export default function MinutesEditorPage() {
+  const params = useParams();
+  const searchParams = useSearchParams();
+  const router = useRouter();
+  
+  const workshopId = params.id as string;
+  const engagementId = params.engagementId as string;
+  const minutesId = searchParams.get('id');
+
+  const [minutes, setMinutes] = useState<Minutes | null>(null);
+  const [sections, setSections] = useState<MinutesSection>({
+    attendees: [],
+    decisions: [],
+    actions: [],
+    questions: []
+  });
+  const [loading, setLoading] = useState(true);
+  const [saving, setSaving] = useState(false);
+  const [publishing, setPublishing] = useState(false);
+  const [error, setError] = useState<string>('');
+
+  useEffect(() => {
+    if (minutesId) {
+      loadMinutes();
+    }
+  }, [minutesId]);
+
+  const loadMinutes = async () => {
+    try {
+      setLoading(true);
+      const minutesData = await getMinutes(minutesId!);
+      setMinutes(minutesData);
+      setSections(minutesData.sections);
+      setError('');
+    } catch (err) {
+      console.error('Failed to load minutes:', err);
+      setError('Failed to load minutes');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const handleSave = async () => {
+    if (!minutes) return;
+    
+    try {
+      setSaving(true);
+      setError('');
+      const updated = await updateMinutes(minutes.id, { sections });
+      setMinutes(updated);
+    } catch (err) {
+      if (err instanceof MinutesConflictError) {
+        setError(err.message);
+      } else {
+        setError('Failed to save minutes');
+      }
+    } finally {
+      setSaving(false);
+    }
+  };
+
+  const handlePublish = async () => {
+    if (!minutes) return;
+    
+    try {
+      setPublishing(true);
+      setError('');
+      const published = await publishMinutes(minutes.id);
+      setMinutes(published);
+    } catch (err) {
+      if (err instanceof MinutesConflictError) {
+        setError(err.message);
+      } else {
+        setError('Failed to publish minutes');
+      }
+    } finally {
+      setPublishing(false);
+    }
+  };
+
+  const handleCreateNewVersion = async () => {
+    if (!minutes) return;
+    
+    try {
+      setError('');
+      const newVersion = await createNewVersion(minutes.id);
+      router.push(`/e/${engagementId}/workshops/${workshopId}/minutes?id=${newVersion.id}`);
+    } catch (err) {
+      setError('Failed to create new version');
+    }
+  };
+
+  const updateListField = (field: keyof MinutesSection, index: number, value: string) => {
+    setSections(prev => ({
+      ...prev,
+      [field]: prev[field].map((item, i) => i === index ? value : item)
+    }));
+  };
+
+  const addListItem = (field: keyof MinutesSection) => {
+    setSections(prev => ({
+      ...prev,
+      [field]: [...prev[field], '']
+    }));
+  };
+
+  const removeListItem = (field: keyof MinutesSection, index: number) => {
+    setSections(prev => ({
+      ...prev,
+      [field]: prev[field].filter((_, i) => i !== index)
+    }));
+  };
+
+  const renderEditableList = (
+    title: string, 
+    field: keyof MinutesSection, 
+    placeholder: string
+  ) => {
+    const isReadonly = minutes?.status === 'published';
+    
+    return (
+      <div className="space-y-3">
+        <div className="flex justify-between items-center">
+          <h3 className="text-lg font-medium text-gray-900">{title}</h3>
+          {!isReadonly && (
+            <button
+              onClick={() => addListItem(field)}
+              className="text-blue-600 hover:text-blue-800 text-sm"
+            >
+              + Add
+            </button>
+          )}
+        </div>
+        <div className="space-y-2">
+          {sections[field].map((item, index) => (
+            <div key={index} className="flex gap-2">
+              <input
+                type="text"
+                value={item}
+                onChange={(e) => updateListField(field, index, e.target.value)}
+                placeholder={placeholder}
+                readOnly={isReadonly}
+                className={`flex-1 px-3 py-2 border rounded-md ${
+                  isReadonly 
+                    ? 'bg-gray-50 border-gray-200 text-gray-600' 
+                    : 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent'
+                }`}
+              />
+              {!isReadonly && (
+                <button
+                  onClick={() => removeListItem(field, index)}
+                  className="text-red-600 hover:text-red-800 px-2"
+                >
+                  Ã—
+                </button>
+              )}
+            </div>
+          ))}
+          {sections[field].length === 0 && (
+            <p className="text-gray-500 text-sm italic">No {field} recorded</p>
+          )}
+        </div>
+      </div>
+    );
+  };
+
+  if (loading) {
+    return (
+      <div className="max-w-4xl mx-auto p-6">
+        <div className="animate-pulse space-y-6">
+          <div className="h-8 bg-gray-200 rounded w-1/3"></div>
+          <div className="space-y-4">
+            <div className="h-32 bg-gray-200 rounded"></div>
+            <div className="h-32 bg-gray-200 rounded"></div>
+          </div>
+        </div>
+      </div>
+    );
+  }
+
+  if (!minutes) {
+    return (
+      <div className="max-w-4xl mx-auto p-6">
+        <div className="text-center">
+          <p className="text-gray-600">Minutes not found</p>
+          <button
+            onClick={() => router.push(`/e/${engagementId}/workshops/${workshopId}`)}
+            className="mt-4 text-blue-600 hover:text-blue-800"
+          >
+            â† Back to Workshop
+          </button>
+        </div>
+      </div>
+    );
+  }
+
+  const isPublished = minutes.status === 'published';
+
+  return (
+    <div className="max-w-4xl mx-auto p-6 space-y-6">
+      <header className="flex justify-between items-start">
+        <div>
+          <h1 className="text-3xl font-bold text-gray-900">Minutes Editor</h1>
+          <div className="flex items-center gap-4 mt-2 text-sm text-gray-600">
+            <span className={`px-2 py-1 rounded-full ${
+              isPublished ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'
+            }`}>
+              {isPublished ? 'Published' : 'Draft'}
+            </span>
+            {minutes.published_at && (
+              <span>Published: {new Date(minutes.published_at).toLocaleString()}</span>
+            )}
+          </div>
+        </div>
+        <button
+          onClick={() => router.push(`/e/${engagementId}/workshops/${workshopId}`)}
+          className="text-blue-600 hover:text-blue-800"
+        >
+          â† Back to Workshop
+        </button>
+      </header>
+
+      {error && (
+        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
+          {error}
+        </div>
+      )}
+
+      {isPublished && (
+        <div className="bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded">
+          <div className="flex justify-between items-start">
+            <div>
+              <p className="font-medium">Minutes are immutable after publishing</p>
+              {minutes.content_hash && (
+                <p className="text-sm font-mono mt-1">Hash: {minutes.content_hash}</p>
+              )}
+            </div>
+            <button
+              onClick={handleCreateNewVersion}
+              className="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700"
+            >
+              Create New Version
+            </button>
+          </div>
+        </div>
+      )}
+
+      <div className="bg-white shadow rounded-lg p-6 space-y-8">
+        {renderEditableList('Attendees', 'attendees', 'Enter attendee name')}
+        {renderEditableList('Decisions', 'decisions', 'Enter decision made')}
+        {renderEditableList('Actions', 'actions', 'Enter action item')}
+        {renderEditableList('Questions', 'questions', 'Enter question or concern')}
+      </div>
+
+      {!isPublished && (
+        <div className="flex justify-end gap-4">
+          <button
+            onClick={handleSave}
+            disabled={saving}
+            className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 disabled:bg-gray-400"
+          >
+            {saving ? 'Saving...' : 'Save Draft'}
+          </button>
+          <button
+            onClick={handlePublish}
+            disabled={publishing}
+            className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 disabled:bg-green-400"
+          >
+            {publishing ? 'Publishing...' : 'Publish Minutes'}
+          </button>
+        </div>
+      )}
+    </div>
+  );
+}
\ No newline at end of file
diff --git a/web/lib/minutes.ts b/web/lib/minutes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e5cd4d4fd656651d28e261f6e4b06d2ce5dd11f
--- /dev/null
+++ b/web/lib/minutes.ts
@@ -0,0 +1,81 @@
+import { apiFetch } from './api';
+import { Minutes, GenerateMinutesRequest, UpdateMinutesRequest, MinutesError } from '../types/minutes';
+
+export class MinutesConflictError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'MinutesConflictError';
+  }
+}
+
+export async function generateDraftMinutes(
+  workshopId: string, 
+  request: GenerateMinutesRequest = {}
+): Promise<Minutes> {
+  try {
+    return await apiFetch(`/workshops/${workshopId}/minutes/generate`, {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(request),
+    });
+  } catch (error) {
+    throw new Error(`Failed to generate minutes: ${error}`);
+  }
+}
+
+export async function updateMinutes(
+  minutesId: string, 
+  request: UpdateMinutesRequest
+): Promise<Minutes> {
+  try {
+    return await apiFetch(`/minutes/${minutesId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(request),
+    });
+  } catch (error) {
+    if (error instanceof Error && error.message.includes('409')) {
+      throw new MinutesConflictError('Cannot modify published minutes. Create a new version instead.');
+    }
+    throw new Error(`Failed to update minutes: ${error}`);
+  }
+}
+
+export async function publishMinutes(minutesId: string): Promise<Minutes> {
+  try {
+    return await apiFetch(`/minutes/${minutesId}/publish`, {
+      method: 'POST',
+    });
+  } catch (error) {
+    if (error instanceof Error && error.message.includes('409')) {
+      throw new MinutesConflictError('Minutes are already published and cannot be modified.');
+    }
+    throw new Error(`Failed to publish minutes: ${error}`);
+  }
+}
+
+export async function createNewVersion(minutesId: string): Promise<Minutes> {
+  try {
+    return await apiFetch(`/minutes/${minutesId}/new-version`, {
+      method: 'POST',
+    });
+  } catch (error) {
+    throw new Error(`Failed to create new version: ${error}`);
+  }
+}
+
+export async function getMinutes(minutesId: string): Promise<Minutes> {
+  try {
+    return await apiFetch(`/minutes/${minutesId}`);
+  } catch (error) {
+    throw new Error(`Failed to get minutes: ${error}`);
+  }
+}
+
+export async function getWorkshopMinutes(workshopId: string): Promise<Minutes[]> {
+  try {
+    return await apiFetch(`/workshops/${workshopId}/minutes`);
+  } catch (error) {
+    throw new Error(`Failed to get workshop minutes: ${error}`);
+  }
+}
\ No newline at end of file
diff --git a/web/types/minutes.ts b/web/types/minutes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7111974217750c0fd0740e3941523f6f5115753b
--- /dev/null
+++ b/web/types/minutes.ts
@@ -0,0 +1,36 @@
+// Minutes-related TypeScript types matching backend models
+
+export interface MinutesSection {
+  attendees: string[];
+  decisions: string[];
+  actions: string[];
+  questions: string[];
+}
+
+export interface Minutes {
+  id: string;
+  workshop_id: string;
+  status: 'draft' | 'published';
+  sections: MinutesSection;
+  generated_by: 'agent' | 'human';
+  published_at?: string;
+  content_hash?: string;
+  parent_id?: string;
+  created_at: string;
+  updated_by: string;
+}
+
+export interface GenerateMinutesRequest {
+  workshop_type?: string;
+  attendees?: string[];
+  additional_context?: Record<string, any>;
+}
+
+export interface UpdateMinutesRequest {
+  sections: MinutesSection;
+}
+
+export interface MinutesError {
+  detail: string;
+  status_code: number;
+}
\ No newline at end of file
