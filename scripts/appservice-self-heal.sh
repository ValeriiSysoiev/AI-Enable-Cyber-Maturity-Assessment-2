#!/bin/bash

# App Service Self-Healing Logic Script
# Automated recovery commands for common failure scenarios
# Auto-generated by AppServiceConfigurator Agent

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${SCRIPT_DIR}/../logs/agents/appservice-configurator.log"
RESOURCE_GROUP="rg-cybermat-prd"
WEB_APP_NAME="web-cybermat-prd"
WEB_APP_URL="https://${WEB_APP_NAME}.azurewebsites.net"

# Logging function
log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "${timestamp} - SELF-HEAL - $1" | tee -a "$LOG_FILE"
}

# Health check function
check_app_health() {
    log "Performing health check on $WEB_APP_URL"
    
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" "$WEB_APP_URL" --max-time 30 || echo "000")
    local response_time=$(curl -s -o /dev/null -w "%{time_total}" "$WEB_APP_URL" --max-time 30 || echo "999")
    
    echo "$http_code"
}

# Get app service status
get_app_status() {
    local status=$(az webapp show \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --query "state" \
        --output tsv)
    echo "$status"
}

# Scenario 1: App not responding (HTTP timeout or 5xx errors)
heal_app_not_responding() {
    log "=== HEALING: App Not Responding ==="
    
    log "Step 1: Checking app service status..."
    local app_status=$(get_app_status)
    log "App service status: $app_status"
    
    if [ "$app_status" != "Running" ]; then
        log "Step 2: App service is not running. Starting app service..."
        az webapp start \
            --resource-group "$RESOURCE_GROUP" \
            --name "$WEB_APP_NAME" \
            --output table | tee -a "$LOG_FILE"
        
        log "Waiting 60 seconds for app to start..."
        sleep 60
    else
        log "Step 2: App service is running. Performing restart..."
        az webapp restart \
            --resource-group "$RESOURCE_GROUP" \
            --name "$WEB_APP_NAME" \
            --output table | tee -a "$LOG_FILE"
        
        log "Waiting 60 seconds for app to restart..."
        sleep 60
    fi
    
    log "Step 3: Verifying recovery..."
    local health_check=$(check_app_health)
    log "Post-restart health check: HTTP $health_check"
}

# Scenario 2: ZIP deployment recovery
heal_deployment_issues() {
    log "=== HEALING: Deployment Issues ==="
    
    log "Step 1: Checking deployment status..."
    local deployment_status=$(az webapp deployment list \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --query "[0].{status:status,deploymentId:id}" \
        --output json 2>/dev/null || echo '{"status":"Unknown","deploymentId":"N/A"}')
    
    log "Latest deployment status: $(echo $deployment_status | jq -r '.status')"
    
    log "Step 2: Redeploying from local ZIP if available..."
    local latest_zip="${SCRIPT_DIR}/../web-deploy.zip"
    
    if [ -f "$latest_zip" ]; then
        log "Found deployment package: $latest_zip"
        log "Initiating ZIP deployment..."
        
        az webapp deployment source config-zip \
            --resource-group "$RESOURCE_GROUP" \
            --name "$WEB_APP_NAME" \
            --src "$latest_zip" \
            --output table | tee -a "$LOG_FILE"
        
        log "Waiting 120 seconds for deployment to complete..."
        sleep 120
    else
        log "No deployment package found. Triggering application restart instead..."
        heal_app_not_responding
    fi
    
    log "Step 3: Verifying deployment recovery..."
    local health_check=$(check_app_health)
    log "Post-deployment health check: HTTP $health_check"
}

# Scenario 3: Startup command issues
heal_startup_command_issues() {
    log "=== HEALING: Startup Command Issues ==="
    
    log "Step 1: Trying primary startup command..."
    az webapp config set \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --startup-file "node .next/standalone/server.js" \
        --output table | tee -a "$LOG_FILE"
    
    log "Waiting 45 seconds for restart..."
    sleep 45
    
    local health_check=$(check_app_health)
    log "Health check with primary startup: HTTP $health_check"
    
    if [ "$health_check" != "200" ]; then
        log "Step 2: Primary startup failed. Trying fallback startup command..."
        az webapp config set \
            --resource-group "$RESOURCE_GROUP" \
            --name "$WEB_APP_NAME" \
            --startup-file "node server.js" \
            --output table | tee -a "$LOG_FILE"
        
        log "Waiting 45 seconds for restart with fallback..."
        sleep 45
        
        health_check=$(check_app_health)
        log "Health check with fallback startup: HTTP $health_check"
        
        if [ "$health_check" != "200" ]; then
            log "Step 3: Both startup commands failed. Trying minimal startup..."
            az webapp config set \
                --resource-group "$RESOURCE_GROUP" \
                --name "$WEB_APP_NAME" \
                --startup-file "npm start" \
                --output table | tee -a "$LOG_FILE"
            
            log "Waiting 60 seconds for restart with npm start..."
            sleep 60
            
            health_check=$(check_app_health)
            log "Health check with npm start: HTTP $health_check"
        fi
    fi
}

# Scenario 4: Runtime configuration issues
heal_runtime_issues() {
    log "=== HEALING: Runtime Configuration Issues ==="
    
    log "Step 1: Resetting Node.js runtime to known working version..."
    az webapp config set \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --linux-fx-version "NODE|20-lts" \
        --output table | tee -a "$LOG_FILE"
    
    log "Step 2: Resetting critical environment variables..."
    az webapp config appsettings set \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --settings \
            "WEBSITE_NODE_DEFAULT_VERSION=20-lts" \
            "PORT=8080" \
            "WEBSITES_PORT=8080" \
            "NODE_ENV=production" \
        --output table | tee -a "$LOG_FILE"
    
    log "Step 3: Restarting app with corrected runtime..."
    az webapp restart \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --output table | tee -a "$LOG_FILE"
    
    log "Waiting 60 seconds for runtime correction to take effect..."
    sleep 60
    
    local health_check=$(check_app_health)
    log "Post-runtime-fix health check: HTTP $health_check"
}

# Scenario 5: Memory/performance issues
heal_performance_issues() {
    log "=== HEALING: Performance Issues ==="
    
    log "Step 1: Adjusting Node.js memory settings..."
    az webapp config appsettings set \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --settings \
            "NODE_OPTIONS=--max-old-space-size=1024 --optimize-for-size" \
            "WEBSITE_DYNAMIC_CACHE=0" \
            "NEXT_TELEMETRY_DISABLED=1" \
        --output table | tee -a "$LOG_FILE"
    
    log "Step 2: Enabling always-on and HTTP/2..."
    az webapp config set \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --always-on true \
        --http20-enabled true \
        --output table | tee -a "$LOG_FILE"
    
    log "Step 3: Restarting for performance optimizations..."
    az webapp restart \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEB_APP_NAME" \
        --output table | tee -a "$LOG_FILE"
    
    log "Waiting 60 seconds for performance optimizations..."
    sleep 60
    
    local health_check=$(check_app_health)
    log "Post-optimization health check: HTTP $health_check"
}

# Comprehensive healing attempt
comprehensive_heal() {
    log "=== COMPREHENSIVE HEALING SEQUENCE ==="
    
    local initial_health=$(check_app_health)
    log "Initial health status: HTTP $initial_health"
    
    if [ "$initial_health" = "200" ]; then
        log "App is healthy. No healing required."
        return 0
    fi
    
    # Try healing scenarios in order of likelihood
    heal_app_not_responding
    local health=$(check_app_health)
    if [ "$health" = "200" ]; then
        log "SUCCESS: App healed after restart"
        return 0
    fi
    
    heal_startup_command_issues
    health=$(check_app_health)
    if [ "$health" = "200" ]; then
        log "SUCCESS: App healed after startup command fix"
        return 0
    fi
    
    heal_runtime_issues
    health=$(check_app_health)
    if [ "$health" = "200" ]; then
        log "SUCCESS: App healed after runtime fix"
        return 0
    fi
    
    heal_performance_issues
    health=$(check_app_health)
    if [ "$health" = "200" ]; then
        log "SUCCESS: App healed after performance optimization"
        return 0
    fi
    
    heal_deployment_issues
    health=$(check_app_health)
    if [ "$health" = "200" ]; then
        log "SUCCESS: App healed after redeployment"
        return 0
    fi
    
    log "WARNING: All healing attempts completed. Final health status: HTTP $health"
    log "Manual intervention may be required."
    return 1
}

# Monitor and auto-heal function
monitor_and_heal() {
    log "=== STARTING MONITORING MODE ==="
    log "Will check health every 5 minutes and auto-heal if needed"
    
    local consecutive_failures=0
    local max_failures=3
    
    while true; do
        local health=$(check_app_health)
        local current_time=$(date '+%H:%M:%S')
        
        if [ "$health" = "200" ]; then
            log "[$current_time] Health check: OK (HTTP $health)"
            consecutive_failures=0
        else
            consecutive_failures=$((consecutive_failures + 1))
            log "[$current_time] Health check: FAILED (HTTP $health) - Failure count: $consecutive_failures"
            
            if [ $consecutive_failures -ge $max_failures ]; then
                log "[$current_time] TRIGGER: $consecutive_failures consecutive failures detected. Starting healing..."
                comprehensive_heal
                consecutive_failures=0
                log "[$current_time] Healing sequence completed. Resuming monitoring..."
            fi
        fi
        
        # Sleep for 5 minutes
        sleep 300
    done
}

# Usage information
show_usage() {
    echo "App Service Self-Healing Script Usage:"
    echo ""
    echo "Options:"
    echo "  --check              : Perform single health check"
    echo "  --restart            : Heal app not responding scenario"
    echo "  --startup            : Heal startup command issues"
    echo "  --runtime            : Heal runtime configuration issues"
    echo "  --performance        : Heal performance issues"
    echo "  --deployment         : Heal deployment issues"
    echo "  --comprehensive      : Run all healing scenarios"
    echo "  --monitor            : Start monitoring mode (checks every 5 minutes)"
    echo "  --help               : Show this usage information"
}

# Main execution
main() {
    log "=========================================="
    log "APP SERVICE SELF-HEALING INITIATED"
    log "Target: $WEB_APP_NAME"
    log "Timestamp: $(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    log "=========================================="
    
    case "${1:-}" in
        --check)
            local health=$(check_app_health)
            log "Health check result: HTTP $health"
            ;;
        --restart)
            heal_app_not_responding
            ;;
        --startup)
            heal_startup_command_issues
            ;;
        --runtime)
            heal_runtime_issues
            ;;
        --performance)
            heal_performance_issues
            ;;
        --deployment)
            heal_deployment_issues
            ;;
        --comprehensive)
            comprehensive_heal
            ;;
        --monitor)
            monitor_and_heal
            ;;
        --help)
            show_usage
            ;;
        *)
            log "No specific healing option provided. Running comprehensive healing..."
            comprehensive_heal
            ;;
    esac
    
    log "=========================================="
    log "SELF-HEALING OPERATION COMPLETED"
    log "Check log file for details: $LOG_FILE"
    log "=========================================="
}

# Handle script interruption for monitoring mode
trap 'log "Self-healing script interrupted"; exit 1' INT TERM

# Execute main function
main "$@"